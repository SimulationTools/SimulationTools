(* Copyright 2010-2012 Ian Hinder and Barry Wardell

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*)

BeginPackage["SimulationTools`ProfileCall`"];

Unprotect[ProfileCall];
ClearAll[ProfileCall];
ProfileCall(*::usage = "ProfileCall[name, expression] evaluates expression and adds the elapsed time to ProfileCallTime[name] and adds one to ProfileCallCount[name].  See also ClearProfileCall."*);
ProfileCallTime;
ProfileCallCount;
ClearProfileCall(*::usage = "ClearProfileCall[] zeroes all counters and timers generated by the ProfileCall function."*);
Timer;

AutoProfile;
AutoProfileTime;
AutoProfileCount;
ClearAutoProfile;
AutoProfileReportTime;
AutoProfileReportCount;
WithProfiling;

SimulationTools`$AutoProfile;
SimulationTools`NoProfile;

Begin["`Private`"];

ClearProfileCall[] :=
  Module[{},
    Clear[ProfileCallTime];
    Clear[ProfileCallCount]];

SetAttributes[ProfileCall, HoldAll];

ProfileCall[name_, code_] := code;
(* Below is the old implementation of ProfileCall which is currently disabled.

   Module[{time, result, name2, result2, subTimers},
    name2 = Evaluate[name];
    {result2,subTimers} = Reap[{time, result} = AbsoluteTiming[ReleaseHold[code]]];
    If[Head[ProfileCallTime[name2]] === ProfileCallTime, ProfileCallTime[name2] = 0.0];
    If[Head[ProfileCallCount[name2]] === ProfileCallCount, ProfileCallCount[name2] = 0];
    ProfileCallTime[name2] += time;
    ProfileCallCount[name2] += 1;
    Sow[Timer[name2,time,If[subTimers === {}, {}, subTimers[[1]]]]];
    result];
*)

(* The code below is a prototype for handling a tree of timer
   information from ProfileCall.  It needs to be tidied up and a good
   interface defined.  Example of use:

     {result, timers} = Reap@MyProfileCall["Total", <code>];

     treeView@addUntimed@
       Timer[timers[[1, 1, 1]], timers[[1, 1, 2]],
         addTimers[timers[[1, 1, 3]], sameq, plus]]
*)

treeView[t : Timer[n_, v_, c_]] :=
 Module[{},
  If[c === {},
   Row[{"  ", v, " ", n}],
   OpenerView[{Row[{v, " ", n}],
     Column[treeView /@ c]}, True]]]

(* Take a list and, for all the members which are "sameq" as each \
other, replace them with the application of "plus" to them *)
add[l_, sameq_, plus_] :=
 Map[plus, Gather[l, sameq]];

addTimers[ts_List, sameq_, plus_] :=
 add[Map[Timer[#[[1]], #[[2]], addTimers[#[[3]], sameq, plus]] &, ts],
   sameq, plus];

sameq[Timer[n1_, v1_, s1_], Timer[n2_, v2_, s2_]] :=
 n1 === n2 && Length[s1] == Length[s2] &&
  And @@ MapThread[sameq, {s1, s2}];

plus[ts_List] :=
 Timer[ts[[1, 1]], Plus @@ Map[#[[2]] &, ts],
  MapThread[plus[{##}] &, Map[#[[3]] &, ts]]];

addUntimed[Timer[n_, v_, s_List]] :=
 If[Length[s] === 0, Timer[n, v, s],
  Module[{total},
   total = Plus @@ Map[#[[2]] &, s];
   Timer[n, v,
    Append[Map[addUntimed, s], Timer["untimed", v - total, {}]]]]];

(****************************************************************)
(* ClearAutoProfile *)
(****************************************************************)

ClearAutoProfile[] :=
  Module[{},
    Clear[AutoProfileTime];
    Clear[AutoProfileCount]];

(****************************************************************)
(* AutoProfile *)
(****************************************************************)

SetAttributes[AutoProfile, HoldAll];
SimulationTools`NoProfile[AutoProfile] = True;
AutoProfile[name_, code_] :=
   Module[{time, result, name2, result2, subTimers},
    name2 = Evaluate[name];
    (* {result2,subTimers} = Reap[{time, result} = AbsoluteTiming[ReleaseHold[code]]]; *)
    {time, result} = AbsoluteTiming[ReleaseHold[code]];
    If[Head[AutoProfileTime[name2]] === AutoProfileTime, AutoProfileTime[name2] = 0.0];
    If[Head[AutoProfileCount[name2]] === AutoProfileCount, AutoProfileCount[name2] = 0];
    AutoProfileTime[name2] += time;
    AutoProfileCount[name2] += 1;
    (* Sow[Timer[name2,time,If[subTimers === {}, {}, subTimers[[1]]]]]; *)
    result];

(****************************************************************)
(* AutoProfileReportTime *)
(****************************************************************)

(* TODO: combine these reports into a single report that shows both
   time and count *)

AutoProfileReportTime[] :=
  Module[{},
    Reverse@SortBy[DownValues[AutoProfileTime], #[[2]] &] /. 
    HoldPattern -> HoldForm /. ((x_ :> y_) :> {y, x}) /. 
    AutoProfileTime[x_] :> x // TableForm];

(****************************************************************)
(* AutoProfileReportCount *)
(****************************************************************)

AutoProfileReportCount[] :=
  Module[{},
    Reverse@SortBy[DownValues[AutoProfileCount], #[[2]] &] /. 
    HoldPattern -> HoldForm /. ((x_ :> y_) :> {y, x}) /. 
    AutoProfileCount[x_] :> x // TableForm];

(****************************************************************)
(* WithProfiling *)
(****************************************************************)

(* cleanArg[arg_] :=  *)
(*   arg /. ((y_Symbol)[xs___] /;  *)
(*       MemberQ[Attributes[y], ReadProtected]) ->  *)
(*     y;(\*Not ideal,but robust*\) *)

(* forStringForm[s_String] := StringReplace[s, "`" -> "`.`"]; *)

SetAttributes[WithProfiling, HoldAll];

If[SimulationTools`$AutoProfile === True,

WithProfiling[symbolPattern_, expr_] := 
  Module[{expr1, inCheck}, expr1 := expr;
   Internal`InheritedBlock[{SetDelayed}, Unprotect[SetDelayed];
    SetDelayed[(fn_Symbol /; (StringMatchQ[Context[fn], 
             symbolPattern] && SimulationTools`NoProfile[fn] =!= True))[args___], 
       rhs_] /; ! TrueQ[inCheck] := 
     Block[{inCheck = True},(*Print["Defining ",fn,"[",StringJoin@
      Riffle[ToString/@{args},","],"]"];*)
      fn[args] :=
       (* TODO: store arguments as well as function name so that
          recursive functions are not overcounted *)
       AutoProfile[
         ToString[fn (*HoldForm@pat*)]
(*        forStringForm@ToString[fn] <> "[" <> 
         StringJoin[
          Riffle[forStringForm@
              ToString[InputForm[cleanArg[#]]] & /@ {pat}, ", "]] <> "]"*),
        rhs]];
    Protect[SetDelayed];
    expr1]],

(* else *)
WithProfiling[symbolPattern_, expr_] := expr];

End[];

EndPackage[];
